-- Enable necessary extensions
create extension if not exists "vector" with schema public;

-- Core Entities

-- Users table (extends Supabase Auth, but usually handled via triggers or just linking by ID)
-- For this schema, we'll create a public profiles table that references auth.users
create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  full_name text,
  avatar_url text,
  credit_balance int default 0,
  plan_tier text default 'free', -- 'free', 'pro', 'enterprise'
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Surveys: Metadata
create table public.surveys (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  name text not null,
  description text,
  status text default 'draft', -- 'draft', 'active', 'archived'
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Demographic Configs: User's target demographics
create table public.demographic_configs (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  name text not null,
  constraints jsonb not null default '{}'::jsonb, -- e.g., {"age": "18-24", "party": "Republican"}
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Probes: Questions in a survey
create table public.probes (
  id bigint generated by default as identity primary key,
  survey_id bigint references public.surveys(id) on delete cascade not null,
  content text not null,
  type text default 'open_ended', -- 'multiple_choice', 'open_ended'
  options jsonb, -- For multiple choice options
  order_index int default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- The Persona Engine

-- Backstories: The central asset
create table public.backstories (
  id bigint generated by default as identity primary key,
  content text not null, -- Full generated interview transcript
  model_signature text, -- e.g., "Llama-3-70B"
  demographics jsonb default '{}'::jsonb, -- Pre-labeled tags: { "age": "...", "gender": "..." }
  custom_tags jsonb default '{}'::jsonb, -- Dynamic tags: { "owns_tesla": true }
  embedding vector(1536), -- Optional: for semantic search
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Execution & Results

-- Survey Runs: Instance of a survey being executed
create table public.survey_runs (
  id bigint generated by default as identity primary key,
  survey_id bigint references public.surveys(id) on delete cascade not null,
  config_id bigint references public.demographic_configs(id) on delete set null,
  methodology text not null, -- 'ALTERITY', 'DEMOGRAPHIC_FORCING', 'SIMPLE_PERSONA'
  status text default 'QUEUED', -- 'QUEUED', 'MATCHING', 'INFERENCE', 'COMPLETED', 'FAILED'
  run_config jsonb default '{}'::jsonb, -- e.g. { "model_name": "gpt-4-turbo", "temperature": 0.7 }
  tokens_used int default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  completed_at timestamp with time zone
);

-- Results: Individual responses
create table public.results (
  id bigint generated by default as identity primary key,
  run_id bigint references public.survey_runs(id) on delete cascade not null,
  probe_id bigint references public.probes(id) on delete cascade not null,
  backstory_id bigint references public.backstories(id) on delete set null, -- Nullable for demographic forcing
  response jsonb not null, -- The model's output
  usage_cost float default 0.0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Indexes for performance
create index idx_backstories_demographics on public.backstories using gin (demographics);
create index idx_backstories_custom_tags on public.backstories using gin (custom_tags);
create index idx_results_run_id on public.results(run_id);
create index idx_survey_runs_status on public.survey_runs(status);

-- RLS Policies (Basic Setup - to be refined)
alter table public.profiles enable row level security;
alter table public.surveys enable row level security;
alter table public.demographic_configs enable row level security;
alter table public.probes enable row level security;
alter table public.backstories enable row level security;
alter table public.survey_runs enable row level security;
alter table public.results enable row level security;

-- Configurations: Global settings (e.g. key=PRICING_MODEL)
create table public.configurations (
  key text primary key,
  value jsonb not null,
  description text,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Feature Flags: Toggles
create table public.feature_flags (
  name text primary key,
  is_enabled boolean default false,
  properties jsonb default '{}'::jsonb,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.configurations enable row level security;
alter table public.feature_flags enable row level security;
create policy "Public read access for configs" on public.configurations for select to authenticated using (true);
create policy "Public read access for flags" on public.feature_flags for select to authenticated using (true);

-- Simple policies for now: Users can CRUD their own data. Backstories are readable by all (or system only).
create policy "Users can view own profile" on public.profiles for select using (auth.uid() = id);
create policy "Users can update own profile" on public.profiles for update using (auth.uid() = id);

create policy "Users can crud own surveys" on public.surveys using (auth.uid() = user_id);
create policy "Users can crud own configs" on public.demographic_configs using (auth.uid() = user_id);
create policy "Users can crud own probes via survey" on public.probes using (
  exists (select 1 from public.surveys where id = probes.survey_id and user_id = auth.uid())
);

-- Backstories are generally system-managed but might be viewable
create policy "Backstories are viewable by authenticated users" on public.backstories for select to authenticated using (true);

create policy "Users can crud own runs via survey" on public.survey_runs using (
  exists (select 1 from public.surveys where id = survey_runs.survey_id and user_id = auth.uid())
);

create policy "Users can view results of own runs" on public.results for select using (
  exists (select 1 from public.survey_runs r join public.surveys s on r.survey_id = s.id where r.id = results.run_id and s.user_id = auth.uid())
);
